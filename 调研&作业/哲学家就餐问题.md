

# 哲学家就餐问题

## 吕佳鸿 10235501436

## 问题表述

哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌上有五碗意大利面，每位哲学家之间各有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和五根筷子而不是意大利面和餐叉来描述，因为吃米饭必须用两根筷子。

这个问题不考虑意大利面有多少，也不考虑哲学家的胃有多大。假设两者都是无限大。

问题在于如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去。

## 会出现的问题

假设某一时刻，所有的哲学家都想要吃东西，他们同时拿起了各自左手边的餐叉，然后当他们想要拿起右手边的餐叉时，发现已经被右边的哲学家拿起来了，如果每一个哲学家都不同意放弃自己已经拿到手的餐叉，则整个系统就无法运行下去了，出现了被称为“死锁”的状态。

另一种情况，哲学家觉得不能这么自私，如果自己已经拿起了一个餐叉，而迟迟无法获得另一个餐叉时，则他在等待一段时间后会放下自己已经拿起的餐叉。当所有哲学家都这样想，他们同时拿起左手边的餐叉，等待相同的时间，又同时放下餐叉，然后拿起、放下、拿起、放下如此循环，出现被成为“活锁”的状态。

## 解决方案

### 服务生方法

一个简单的解法是引入一个餐厅服务生，哲学家要想得到餐叉，必须先叫服务生送给他，服务生按先来后到的顺序服务完一位哲学家后才能服务下一为哲学家。这时，如果正在被服务生服务的哲学家两边的餐叉都没有被占用的话，这位哲学家就一定会得到这两个餐叉，而不会被别的哲学家抢走，从而避免死锁。

这种解法的特点是简单但并发度很低。举个例子，假设现在2号哲学家已经在就餐了，他占用了2号和3号餐叉，这时1号哲学家叫了服务生，服务生给了1号哲学家1号餐叉，随后发现2号餐叉正在被占用，则服务生必须等待2号哲学家就餐结束才能把2号餐叉给1号哲学家。因为服务生对1号哲学家的服务还没有结束，所以这时有其他哲学家申请服务的时候服务生无法响应，造成整个系统都阻塞，知道2号哲学家就餐结束。

### 资源分级算法

另一个简单的解法是为资源分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放。对应在哲学家就餐问题中就是为各个餐叉设置 1 - 2 - 3 - 4 - 5 的序号，每一个哲学家总是先拿起左右两边编号较低的餐叉，再拿编号较高的。用完餐叉后，他总是先放下编号较高的餐叉，再放下编号较低的。在这种情况下，1-4号哲学家都是左边的餐叉序号小，而5号哲学家是右边的餐叉序号小，当1-4号哲学家同时拿起他们手边编号较低的餐叉即1-4号餐叉时，只有编号最高的5号餐叉留在桌上，5号哲学家先申请序号较小的1号，发现已经被拿走，所以他就只能等待。而剩下的那支5号餐叉被4号哲学家成功获得。当4号哲学家吃完后，他会先放下编号最高的餐叉，再放下编号较低的餐叉，从而使得3号哲学家成功获得他所需的第二支餐叉，以此类推，整个系统不会发生死锁。

### Chandy/Misra 算法

1984年，K. Mani Chandy和J. Misra提出了哲学家就餐问题的另一个解法，允许任意的用户（编号P1, ..., Pn）争用任意数量的资源。与资源分级解法不同的是，这里编号可以是任意的。这个解法允许很大的并行性，适用于任意大的问题。

